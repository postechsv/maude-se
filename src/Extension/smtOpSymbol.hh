#ifndef SMT_CHECK_SYMBOL_HH
#define SMT_CHECK_SYMBOL_HH
#include "freeSymbol.hh"
#include "cachedDag.hh"
#include "userLevelRewritingContext.hh"

class VariableGenerator;
class SymbolGetter;

class SmtOpSymbol : public FreeSymbol
{
    NO_COPYING(SmtOpSymbol);

public:
    SmtOpSymbol(int id, int nrArgs, const Vector<int> &strategy);
    // ~SmtOpSymbol();
    bool attachData(const Vector<Sort *> &opDeclaration,
                    const char *purpose,
                    const Vector<const char *> &data);
    bool attachSymbol(const char *purpose, Symbol *symbol);
    bool attachTerm(const char *purpose, Term *term);
    void copyAttachments(Symbol *original, SymbolMap *map);
    void getDataAttachments(const Vector<Sort *> &opDeclaration,
                            Vector<const char *> &purposes,
                            Vector<Vector<const char *>> &data);
    void getSymbolAttachments(Vector<const char *> &purposes,
                              Vector<Symbol *> &symbols);
    void getTermAttachments(Vector<const char *> &purposes,
                            Vector<Term *> &terms);

    void postInterSymbolPass();
    void reset();
    bool eqRewrite(DagNode *subject, RewritingContext &context);

private:
    typedef bool (SmtOpSymbol::*FunctionPtr)(FreeDagNode *subject, RewritingContext &context);

    //
    //	Function signature (generated by macro expansion).
    //
#define MACRO(SymbolName, NrArgs) \
    bool SymbolName(FreeDagNode *subject, RewritingContext &context);
#include "smtOpSignature.cc"
#undef MACRO

private:
    const char *getLogic(DagNode *dag, SymbolGetter *sg);
    DagNode *make_model(VariableGenerator *vg, SymbolGetter *sg);

public:
#define MACRO(SymbolName, SymbolClass, RequiredFlags, NrArgs) \
    SymbolClass *SymbolName;
#include "smtSignature.cc"
#undef MACRO

    CachedDag trueTerm;
    CachedDag falseTerm;

private:
    FunctionPtr function;
};

#endif
