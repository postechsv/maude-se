load file
load metaInterpreter
--- load smt
load smt-check

fmod MAUDE-SE-SYNTAX is
  pr QID-LIST .
  sorts Token Bubble NaBubble NeTokenList .

  op token : Qid -> Token 
  [special(
    id-hook Bubble (1 1)
    op-hook qidSymbol (<Qids> : ~> Qid))] .

  op bubble : QidList -> Bubble
  [special(
    id-hook Bubble (1 -1)
    op-hook qidListSymbol (__ : QidList QidList ~> QidList)
    op-hook qidSymbol (<Qids> : ~> Qid)
    id-hook Exclude (.))] .

  op naBubble : QidList -> NaBubble
  [special(
    id-hook Bubble (1 -1)
    op-hook qidListSymbol (__ : QidList QidList ~> QidList)
    op-hook qidSymbol (<Qids> : ~> Qid)
    id-hook Exclude (. , :))] .

  sorts Optional OptionalList Input Command .
  subsort Optional < OptionalList .
  subsorts Command < Input .

  op select_. : Bubble -> Command .
  op smt-search`[_`,_`]in_:_=>_such`that_using_. : Bubble Bubble NaBubble Bubble Bubble Bubble Bubble -> Command .
  op smt-search`[_]in_:_=>_such`that_using_. : NaBubble NaBubble Bubble Bubble Bubble Bubble -> Command .
  op `{fold`}smt-search`[_`,_`]in_:_=>_such`that_using_. : Bubble Bubble NaBubble Bubble Bubble Bubble Bubble -> Command .
  op `{fold`}smt-search`[_]in_:_=>_such`that_using_. : NaBubble NaBubble Bubble Bubble Bubble Bubble -> Command .
  op check`in_:_using_. : NaBubble Bubble Bubble -> Command .
  op show`model`. : -> Command .
  op show`smt-path`concrete_. : Bubble -> Command .
  op show`smt-path`symbolic_. : Bubble -> Command .
endfm

fmod MAUDE-SE-PRELUDE is
  pr MAUDE-SE-SYNTAX .
  pr META-SMT-CHECK .
  pr META-SMT-SEARCH2 .
endfm

fmod MAYBE{X :: TRIV} is 
  sort Maybe{X} .
  subsort X$Elt < Maybe{X} .
  op null : -> Maybe{X} .
endfm

view Oid from TRIV to CONFIGURATION is
  sort Elt to Oid .
endv

view Module from TRIV to META-MODULE is
  sort Elt to Module .
endv

omod MAUDE-SE-META-INTERPRETER is
  pr META-SMT-CHECK .
  pr META-SMT-SEARCH2 .
  inc STD-STREAM .
  inc LEXICAL .
  inc MAYBE{Oid} * (op maybe to null) .
  inc MAYBE{Qid} * (op maybe to null) .
  inc MAYBE{Module} * (op maybe to null) .
  inc META-INTERPRETER .

  sort SearchBound SearchBound? .
  subsort SearchBound < SearchBound? .

  op noSearchBound : -> SearchBound? .
  op {_,_} : Nat Nat -> SearchBound [ctor] . 

  sort SearchResult SearchResult? .
  subsort SearchResult < SearchResult? .

  op noSearchResult : -> SearchResult? .
  op {_} : SmtResult2? -> SearchResult .

  class MaudeSE | mi : Maybe{Oid}, mn : Maybe{Qid}, logic : Maybe{Qid}, 
                  in : QidList, state : Nat, check-result : SmtCheckResult,
                  search-info : TermList, search-fold : Bool, search-bound : SearchBound?, search-result : SearchResult? .

  vars C N N' : Nat .
  vars O O' Y MI : Oid .
  vars MN LO QI : Qid .
  var STR STR2 : String .
  var QIL : QidList .
  vars PT T T' T'' : Term .
  vars NT MT TH MM : Term .
  var TL : TermList .
  vars TY TY' : Type .
  var RES : SmtCheckResult .
  var ASSNS : SatAssignmentSet .
  vars SUBS SUBS' : Substitution .
  var B : Bool .
  var NTL : NeTermList .
  var V : Variable .
  var CO : Constant .
  var MO : Module .
  var ST : Trace2 .
  var RL : Rule .
  vars CD CD' : Condition .
  var TR : Trace2 .
  var SRES : SmtResult2 .
  var SR : SearchResult? .
  var RL-ATTRS : AttrSet .

---------------------------------------
--- MaudeSE Banner
---------------------------------------

  op MAUDE-SE-VERSION : -> String .
  eq MAUDE-SE-VERSION = "1.0.0" .

  op MAUDE-SE-BUILT : -> String .
  eq MAUDE-SE-BUILT = "Mar 25 2025" .
  
  op MAUDE-SE-BANNER : -> String .
  eq MAUDE-SE-BANNER = 
  "\n          ===================================" + 
  "\n                        MaudeSE" +
  "\n               (" + MAUDE-SE-VERSION + " built: " + MAUDE-SE-BUILT + ")" +
  "\n          ===================================" + "\n\n\n" .

---------------------------------------
--- MaudeSE Interpreter
---------------------------------------
  
  op o : -> Oid .

  msg processInput : Oid Term -> Msg .

  op maudeSE : -> Configuration .
  eq maudeSE = <>
    < o : MaudeSE | mi : null, mn : null, logic : null, in : nil, state : 0, check-result : unknown, search-info : empty, search-fold : false, 
                    search-bound : noSearchBound, search-result : noSearchResult >
    write(stdout, o, MAUDE-SE-BANNER)
    createInterpreter(interpreterManager, o, none) .

---------------------------------------
--- Base loading and loop
---------------------------------------

  rl < O : MaudeSE | state : 0, mi : null > wrote(O, O') createdInterpreter(O, Y, MI)
  => < O : MaudeSE | state : 1, mi : MI > insertModule(MI, O, upModule('MAUDE-SE-PRELUDE, true)) .

  rl < O : MaudeSE | state : 1 > insertedModule(O, O')
  => < O : MaudeSE | state : 2 > getLine(stdin, O, "MaudeSE> ") .

  rl < O : MaudeSE | state : 1, mi : MI > interpreterError(O, MI, STR)
  => < O : MaudeSE | state : 2 > getLine(stdin, O, "Module import failed : " + STR + "\n\nMaudeSE> ") .

  rl < O : MaudeSE | state : 2, mi : MI, in : QIL > gotLine(O, O', STR)
  => if tokenize(STR) == 'quit or tokenize(STR) == 'q then 
        < O : MaudeSE | state : 3 > write(stdout, O, "goodbye.\n\n")
        quit(MI, O)
     else 
        < O : MaudeSE | in : QIL tokenize(STR), state : 4 >
        parseTerm(MI, O, 'MAUDE-SE-PRELUDE, none, QIL tokenize(STR), 'Input) fi .

  rl < O : MaudeSE | mi : MI, state : 3 > wrote(O, O') bye(O, MI) => none .

  rl < O : MaudeSE | mi : MI, in : QIL, state : 4 > parsedTerm(O, MI, {T, TY})
  => < O : MaudeSE | mi : MI, in : nil, state : 6 > processInput(O, T) .

  rl < O : MaudeSE | mi : MI, in : QIL, state : 4 > parsedTerm(O, MI, ambiguity({T, TY}, {T', TY'}))
  => < O : MaudeSE | mi : MI, in : nil, state : 5 > write(stdout, O, "Ambiguous input\n\n") .

  rl < O : MaudeSE | mi : MI, in : QIL, state : 4 > parsedTerm(O, MI, noParse(N))
  => if N == size(QIL) then 
        < O : MaudeSE | state : 2 > 
        getLine(stdin, O, "> ")
     else 
        < O : MaudeSE | in : nil, state : 5 > 
        write(stdout, O, "Parse error\n\n") fi .

  rl < O : MaudeSE | state : 5, mi : MI > wrote(O, O') => < O : MaudeSE | state : 3 > wrote(O, O') quit(MI, O) .

  rl < O : MaudeSE | state : 6, mn : null > processInput(O, 'check`in_:_using_.[TL])
  => < O : MaudeSE | state : 2 > getLine(stdin, O, "No module in the system.\n\nMaudeSE> ") .

  rl < O : MaudeSE | state : 6, mi : MI > processInput(O, 'select_.['bubble[T]])
  => < O : MaudeSE | state : 1, mi : MI, mn : downTerm(T, 'default-name) > 
    insertModule(MI, O, upModule(downTerm(T, 'default-name), true)) .

---------------------------------------
--- Check command
---------------------------------------

  rl < O : MaudeSE | state : 6, mi : MI > processInput(O, 'check`in_:_using_.['naBubble[T], 'bubble[T'], 'bubble[T'']])
  => < O : MaudeSE | state : 11, logic : downTerm(T'', 'default-name) > 
    parseTerm(MI, O, downTerm(T, 'default-name), none, downTerm(T', 'default-name), anyType) .

  rl < O : MaudeSE | state : 11, mi : MI, mn : MN, logic : LO > parsedTerm(O, MI, {T, TY})
  => < O : MaudeSE | state : 12 > reduceTerm(MI, O, 'MAUDE-SE-PRELUDE, upTerm(metaSmtCheck(upModule(MN, false), T, LO, true))) .

  rl < O : MaudeSE | state : 12, mi : MI > reducedTerm(O, MI, C, T, TY)
  => < O : MaudeSE | state : 13, check-result : downTerm(T, unknown) > 
     write(stdout, O, toString(downTerm(T, unknown))) .

  rl < O : MaudeSE | state : 13 > wrote(O, O')
  => < O : MaudeSE | state : 2 > getLine(stdin, O, "MaudeSE> ") .

  op toString : SmtCheckResult -> String .
  eq toString(RES) = "result: " + $result2str(RES) + "\n\n" .

  op $result2str : SmtCheckResult -> String .
  eq $result2str(true) = "sat" .
  eq $result2str(false) = "unsat" .
  eq $result2str(unknown) = "unknown" .
  eq $result2str({ASSNS}) = "sat" .

---------------------------------------
--- Show assignment command
---------------------------------------

  rl < O : MaudeSE | state : 6, check-result : RES, mn : MN > processInput(O, 'show`model`..Command)
  => < O : MaudeSE | state : 15 > write(stdout, O, assn2str(upModule(MN, false), RES)) .

  rl < O : MaudeSE | state : 15 > wrote(O, O')
  => < O : MaudeSE | state : 2 > getLine(stdin, O, "MaudeSE> ") .

  op assn2str : Module SmtCheckResult -> String .
  eq assn2str(MO, unknown) = "No assignment.\n\n" .
  eq assn2str(MO, true) = "The check sat result was true, but cannot show an assignment.\n\n" .
  eq assn2str(MO, false) = "error occurs while generating assignment.\n\n" .
  eq assn2str(MO, RES) = "\n assignment: \n" + $assn2str(MO, RES) + "\n" .

  op $assn2str : Module SmtCheckResult -> String .
  eq $assn2str(MO, {(T |-> T'), ASSNS}) = printTokens(
    '\t metaPrettyPrint(MO, getVars(T), T, mixfix with-parens) '|--> 
        metaPrettyPrint(MO, getVars(T'), T', mixfix with-parens) '\n) + $assn2str(MO, {ASSNS}) .
  eq $assn2str(MO, {{STR |-> STR2}, ASSNS}) = "\t" + STR + " |--> " + STR2 + "\n" + $assn2str(MO, {ASSNS}) .
  eq $assn2str(MO, {empty}) = "" .


---------------------------------------
--- SMT search command
---------------------------------------

  rl < O : MaudeSE | state : 6, mi : MI, in : QIL > processInput(O, 'smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[MT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]])
  => < O : MaudeSE | state : 20, mn : downTerm(MM, 'default-name), in : QIL ('smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[MT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]]),
                     search-fold : false > insertModule(MI, O, upModule(downTerm(MM, 'default-name), true)) .

  rl < O : MaudeSE | state : 6, mi : MI, in : QIL > processInput(O, 'smt-search`[_`]in_:_=>_such`that_using_.['naBubble[NT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]])
  => < O : MaudeSE | state : 20, mn : downTerm(MM, 'default-name), in : QIL ('smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[''unbounded.Sort], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]]),
                     search-fold : false > insertModule(MI, O, upModule(downTerm(MM, 'default-name), true)) .

  rl < O : MaudeSE | state : 6, mi : MI, in : QIL > processInput(O, '`{fold`}smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[MT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]])
  => < O : MaudeSE | state : 20, mn : downTerm(MM, 'default-name), in : QIL ('smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[MT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]]),
                     search-fold : true > insertModule(MI, O, upModule(downTerm(MM, 'default-name), true)) .

  rl < O : MaudeSE | state : 6, mi : MI, in : QIL > processInput(O, '`{fold`}smt-search`[_`]in_:_=>_such`that_using_.['naBubble[NT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]])
  => < O : MaudeSE | state : 20, mn : downTerm(MM, 'default-name), in : QIL ('smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[''unbounded.Sort], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]]),
                     search-fold : true > insertModule(MI, O, upModule(downTerm(MM, 'default-name), true)) .

  rl < O : MaudeSE | state : 20, mi : MI, mn : MN, in : ('smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[MT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]]) QIL > insertedModule(O, MI)
  => < O : MaudeSE | state : 21, logic : downTerm(TH, 'default-name), search-info : empty > parseTerm(MI, O, MN, none, downTerm(T, 'default-name), anyType) .


  rl < O : MaudeSE | state : 21, mi : MI, mn : MN, search-info : TL,
                     in : ('smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[MT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]]) QIL > parsedTerm(O, MI, {PT, TY})
  => < O : MaudeSE | state : 22, search-info : (((TL, NT), MT), PT) > parseTerm(MI, O, MN, none, downTerm(T', 'default-name), anyType) .


  rl < O : MaudeSE | state : 22, mi : MI, mn : MN, search-info : TL,
                     in : ('smt-search`[_`,_`]in_:_=>_such`that_using_.['bubble[NT], 'bubble[MT], 'naBubble[MM], 'bubble[T], 'bubble[T'], 'bubble[T''], 'bubble[TH]]) QIL > parsedTerm(O, MI, {PT, TY})
  => < O : MaudeSE | state : 23, search-info : (TL, PT) > parseTerm(MI, O, MN, none, downTerm(T'', 'default-name), anyType) .


  rl < O : MaudeSE | state : 23, mi : MI, mn : MN, search-info : (NT, MT, T, T'),
                     in : ('smt-search`[_`,_`]in_:_=>_such`that_using_.[TL]) QIL, search-bound : noSearchBound > parsedTerm(O, MI, {T'', TY})
  => < O : MaudeSE | state : 24, in : QIL, search-info : (NT, MT, T, T', T''), search-bound : {1, getNum(NT)} > .

---  clear prev

  rl < O : MaudeSE | state : 24, mi : MI, mn : MN, search-info : (NT, MT, T, T', T''), search-bound : {C, N}, logic : LO, search-fold : B >
  => < O : MaudeSE | state : 25, search-info : (NT, MT, T, T', T'') > 
    reduceTerm(MI, O, 'MAUDE-SE-PRELUDE, upTerm(metaSmtSearch(upModule(MN, false), T, T', T'' = 'true.Boolean, '*, getNum(MT), mkSolNum(N), LO, B))) .

  rl < O : MaudeSE | state : 25, mi : MI, mn : MN, search-bound : {C, N} > reducedTerm(O, MI, N', T, TY)
  => < O : MaudeSE | state : 26, search-result : {downTerm(T, (failure).SmtResult2?)} > write(stdout, O, toString(upModule(MN, false), C, downTerm(T, (failure).SmtResult2?))) .

  --- crl < O : MaudeSE | state : 26, search-bound : {C, N}, search-result : SR > wrote(O, O')
  ---  => < O : MaudeSE | state : 24, search-bound : {C + 1, N} > if check(C, N, SR) .

  rl < O : MaudeSE | state : 26, search-bound : {C, N}, search-result : SR > wrote(O, O')
   => < O : MaudeSE | state : 2, search-bound : noSearchBound, search-result : noSearchResult > 
      getLine(stdin, O, "MaudeSE> ") .

  op getNum : Qid -> Bound .
  eq getNum(''unbounded.Sort) = unbounded .
  eq getNum(QI) = downTerm(qid("s_^" + string(downTerm(QI, QI)))['0.Zero], (0).Nat) [owise] .

  op mkSolNum : Nat -> Nat .
  eq mkSolNum(s N) = N .
  eq mkSolNum(0) = 0 . 

  op check : Nat Nat SearchResult? -> Bool .
  eq check(C, N, {failure}) = false .
  eq check(C, N, {SRES}) = C < N .

  op toString : Module Nat SmtResult2? -> String .
   eq toString(MO, C, failure) = "No more solutions.\n\n" .
  ceq toString(MO, C, {T, SUBS, T', SUBS', N', N}) = "\n" +
    "Solution " + string(C, 10) + " (state " + string(N, 10) + ")"              + "\n\n" +
    "Symbolic state:" + "\n " + metaPrintToString(MO, none, T, mixfix, none)    + "\n\n" +
    "Constraint:"     + "\n " + metaPrintToString(MO, none, T', mixfix, none)   + "\n\n" + 
    "Substitution:"   + "\n " + toString(MO, SUBS)                              + "\n\n" +
    "Assignment:"     + "\n " + toString(MO, SUBS')                             + "\n\n" +
    "Concrete state:" + "\n " + metaPrintToString(MO, none, T'', mixfix, none)  + "\n\n" + "\n"
  if T'' := applySubstitution(MO, T, SUBS') .

  op toString : Module Substitution -> String .
  eq toString(MO, (none).Substitution) = "" .
  eq toString(MO, V <- T ; SUBS) 
   = metaPrintToString(MO, none, V, mixfix, none) + " <-- " + metaPrintToString(MO, none, T, mixfix, none) + "\n " + toString(MO, SUBS) .

  op getVars : TermList -> VariableSet .
  eq getVars(V) = V .
  eq getVars(CO) = none .
  eq getVars(QI[TL]) = getVars(TL) .
  eq getVars((T, NTL)) = getVars(T) ; getVars(NTL) .
  eq getVars(empty) = none .

---------------------------------------
--- SMT search path command
---------------------------------------

  rl < O : MaudeSE | state : 6, mi : MI, mn : MN, search-info : (NT, MT, T, T', T''), logic : LO, search-fold : B > processInput(O, 'show`smt-path`concrete_.['bubble[PT]])
  => < O : MaudeSE | state : 30 > reduceTerm(MI, O, 'MAUDE-SE-PRELUDE, upTerm(metaSmtSearchPath(upModule(MN, false), T, T', T'' = 'true.Boolean, '*, getNum(MT), mkSolNum(getNum(PT)), LO, B))) .

  rl < O : MaudeSE | state : 30, mi : MI, mn : MN > reducedTerm(O, MI, C, T, TY)
  => < O : MaudeSE | state : 31 > write(stdout, O, toString(upModule(MN, false), downTerm(T, (failure).Trace2Result?), false) + "\n") .

  rl < O : MaudeSE | state : 31 > wrote(O, O')
  => < O : MaudeSE | state : 2 > getLine(stdin, O, "MaudeSE> ") .

  rl < O : MaudeSE | state : 6, mi : MI, mn : MN, search-info : (NT, MT, T, T', T''), logic : LO, search-fold : B > processInput(O, 'show`smt-path`symbolic_.['bubble[PT]])
  => < O : MaudeSE | state : 35 > reduceTerm(MI, O, 'MAUDE-SE-PRELUDE, upTerm(metaSmtSearchPath(upModule(MN, false), T, T', T'' = 'true.Boolean, '*, getNum(MT), mkSolNum(getNum(PT)), LO, B))) .

  rl < O : MaudeSE | state : 35, mi : MI, mn : MN > reducedTerm(O, MI, C, T, TY)
  => < O : MaudeSE | state : 36 > write(stdout, O, toString(upModule(MN, false), downTerm(T, (failure).Trace2Result?), true) + "\n") .

  rl < O : MaudeSE | state : 36 > wrote(O, O')
  => < O : MaudeSE | state : 2 > getLine(stdin, O, "MaudeSE> ") .

  op toString : Module Trace2Result? Bool -> String .
  eq toString(MO, failure, B) = "Failed to get path.\n\n" .
  eq toString(MO, {TR, SUBS}, false) = toString(MO, TR, SUBS) .

  op toString : Module Trace2 Substitution -> String .
  eq toString(MO, nil, SUBS) = "" .
  eq toString(MO, {T || T', TY}, SUBS) = metaPrintToString(MO, none, inst(T, SUBS), mixfix, none) + "\n" .
  ceq toString(MO, {T || T', TY, RL} ST, SUBS) =
    metaPrintToString(MO, none, T'', mixfix, none)  + "\n" +
    "=====[" + toString(MO, RL) + "]=====>"         + "\n" + toString(MO, ST, SUBS)
  if T'' := inst(T, SUBS) .

  eq toString(MO, {TR, SUBS}, true) = toString(MO, TR) .

  op toString : Module Trace2 -> String .
  eq toString(MO, nil) = "" .
  eq toString(MO, {T || T', TY} ST) = "Constrained Term:" + "\n" +
  " Term:"        + metaPrintToString(MO, none, T, mixfix, none)   + "\n" +
  " Constraint: " + metaPrintToString(MO, none, T', mixfix, none)  + "\n" .

  eq toString(MO, {T || T', TY, RL} ST) = "Constrained Term:" + "\n" +
  " Term:"        + metaPrintToString(MO, none, T, mixfix, none)   + "\n" +
  " Constraint: " + metaPrintToString(MO, none, T', mixfix, none)  + "\n" +
  "=====[" + toString(MO, RL) + "]=====>"                          + "\n" + toString(MO, ST) .

  op toString : Module Rule -> String .
  --- eq printRule(MO, rl T => T' [label(QI)] .) = 'rl '`[ QI '`] ': metaPrettyPrint(MO, getVars(T), T, mixfix with-parens) '=> metaPrettyPrint(MO, getVars(T'), T', mixfix with-parens) .
  --- eq printRule(MO, crl T => T' if CD [label(QI)] .) = 'crl '`[ QI '`] ': metaPrettyPrint(MO, getVars(T), T, mixfix with-parens) '=> metaPrettyPrint(MO, getVars(T'), T', mixfix with-parens) 'if printCond(MO, CD) .
  eq toString(MO, rl T => T' [RL-ATTRS label(QI)] .) = printTokens(QI) .
  eq toString(MO, crl T => T' if CD [RL-ATTRS label(QI)] .) = printTokens(QI) .
  eq toString(MO, RL) = "" [owise] .

  op printCond : Module Condition -> QidList .
  eq printCond(MO, nil) = nil .
  eq printCond(MO, T = T') = metaPrettyPrint(MO, getVars(T), T, mixfix with-parens) '= metaPrettyPrint(MO, getVars(T'), T', mixfix with-parens) .
  eq printCond(MO, CD /\ CD') = printCond(MO, CD) '/\ printCond(MO, CD') .
  eq printCond(MO, T := T') = metaPrettyPrint(MO, getVars(T), T, mixfix with-parens) ':= metaPrettyPrint(MO, getVars(T'), T', mixfix with-parens) .

endom

set show command off . 

erewrite maudeSE .

eof